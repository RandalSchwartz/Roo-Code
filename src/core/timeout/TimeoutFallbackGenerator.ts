import type { ToolName } from "@roo-code/types"
import type { Task } from "../task/Task"
import type { SingleCompletionHandler } from "../../api"

export interface TimeoutFallbackContext {
	toolName: ToolName
	timeoutMs: number
	executionTimeMs: number
	toolParams?: Record<string, any>
	errorMessage?: string
	taskContext?: {
		currentStep?: string
		previousActions?: string[]
		workingDirectory?: string
	}
}

export interface TimeoutFallbackResult {
	success: boolean
	toolCall?: {
		name: "ask_followup_question"
		params: {
			question: string
			follow_up: string
		}
	}
	error?: string
}

/**
 * Generates AI-powered fallback suggestions for timeout scenarios
 */
export class TimeoutFallbackGenerator {
	/**
	 * Generate an AI-powered ask_followup_question tool call for timeout scenarios
	 */
	public static async generateAiFallback(
		context: TimeoutFallbackContext,
		task?: Task,
	): Promise<TimeoutFallbackResult> {
		// Try to use AI to generate contextual suggestions
		if (task?.api && "completePrompt" in task.api) {
			try {
				const aiResult = await this.generateAiSuggestions(context, task.api as SingleCompletionHandler)
				if (aiResult.success) {
					return aiResult
				}
			} catch (error) {
				// AI failed, fall through to static suggestions
			}
		}

		// Fallback to static suggestions if AI fails or is unavailable
		const toolCall = this.generateStaticToolCall(context)

		return {
			success: true,
			toolCall,
		}
	}

	/**
	 * Generate AI-powered suggestions using the task's API handler
	 */
	private static async generateAiSuggestions(
		context: TimeoutFallbackContext,
		apiHandler: SingleCompletionHandler,
	): Promise<TimeoutFallbackResult> {
		try {
			const prompt = this.createAiPrompt(context)
			const aiResponse = await apiHandler.completePrompt(prompt)

			// Parse the AI response to extract suggestions
			const suggestions = this.parseAiResponse(aiResponse)

			if (suggestions.length === 0) {
				throw new Error("No valid suggestions generated by AI")
			}

			const question = `The ${context.toolName} operation timed out after ${Math.round(context.timeoutMs / 1000)} seconds. How would you like to proceed?`

			const followUpXml = suggestions
				.map((suggestion) =>
					suggestion.mode
						? `<suggest mode="${suggestion.mode}">${suggestion.text}</suggest>`
						: `<suggest>${suggestion.text}</suggest>`,
				)
				.join("\n")

			return {
				success: true,
				toolCall: {
					name: "ask_followup_question",
					params: {
						question,
						follow_up: followUpXml,
					},
				},
			}
		} catch (error) {
			return {
				success: false,
				error: error instanceof Error ? error.message : "Unknown error generating AI suggestions",
			}
		}
	}

	/**
	 * Create a prompt for the AI to generate contextual timeout fallback suggestions
	 */
	private static createAiPrompt(context: TimeoutFallbackContext): string {
		const { toolName, timeoutMs, executionTimeMs, toolParams, taskContext } = context

		const timeoutSeconds = Math.round(timeoutMs / 1000)
		const executionSeconds = Math.round(executionTimeMs / 1000)

		let prompt = `A ${toolName} operation has timed out after ${timeoutSeconds} seconds (actual execution time: ${executionSeconds} seconds).

Context:
- Tool: ${toolName}
- Timeout limit: ${timeoutSeconds}s
- Actual execution time: ${executionSeconds}s`

		// Add tool-specific context
		if (toolParams) {
			prompt += `\n- Parameters: ${JSON.stringify(toolParams, null, 2)}`
		}

		// Add task context if available
		if (taskContext) {
			if (taskContext.currentStep) {
				prompt += `\n- Current step: ${taskContext.currentStep}`
			}
			if (taskContext.workingDirectory) {
				prompt += `\n- Working directory: ${taskContext.workingDirectory}`
			}
		}

		prompt += `

Generate exactly 3-4 specific, actionable suggestions for how to proceed after this timeout. Each suggestion should be:
1. Contextually relevant to the specific ${toolName} operation that timed out
2. Actionable and specific (not generic advice)
3. Focused on solving the immediate problem
4. Ordered by likelihood of success

Format your response as a simple numbered list:
1. [First suggestion]
2. [Second suggestion]
3. [Third suggestion]
4. [Fourth suggestion (optional)]

Focus on practical solutions like:
- Breaking the operation into smaller parts
- Using alternative tools or methods
- Adjusting parameters or settings
- Checking for underlying issues
- Optimizing the approach

Keep each suggestion concise (under 80 characters) and actionable.`

		return prompt
	}

	/**
	 * Parse AI response to extract suggestions
	 */
	private static parseAiResponse(response: string): Array<{ text: string; mode?: string }> {
		const suggestions: Array<{ text: string; mode?: string }> = []

		// Look for numbered list items
		const lines = response.split("\n")
		for (const line of lines) {
			const trimmed = line.trim()

			// Match patterns like "1. suggestion", "2) suggestion", etc.
			const match = trimmed.match(/^(\d+)[.)]\s*(.+)$/)
			if (match && match[2]) {
				const suggestionText = match[2].trim()
				if (suggestionText.length > 0 && suggestionText.length <= 120) {
					suggestions.push({ text: suggestionText })
				}
			}
		}

		// If no numbered list found, try to extract sentences
		if (suggestions.length === 0) {
			const sentences = response
				.split(/[.!?]+/)
				.map((s) => s.trim())
				.filter((s) => s.length > 10 && s.length <= 120)
			for (let i = 0; i < Math.min(4, sentences.length); i++) {
				suggestions.push({ text: sentences[i] })
			}
		}

		return suggestions.slice(0, 4) // Limit to 4 suggestions
	}

	/**
	 * Generate static fallback suggestions when AI is unavailable
	 */
	private static generateStaticToolCall(context: TimeoutFallbackContext): TimeoutFallbackResult["toolCall"] {
		const suggestions = this.generateContextualSuggestions(context)

		const question = `The ${context.toolName} operation timed out after ${Math.round(context.timeoutMs / 1000)} seconds. How would you like to proceed?`

		const followUpXml = suggestions
			.map((suggestion) =>
				suggestion.mode
					? `<suggest mode="${suggestion.mode}">${suggestion.text}</suggest>`
					: `<suggest>${suggestion.text}</suggest>`,
			)
			.join("\n")

		return {
			name: "ask_followup_question",
			params: {
				question,
				follow_up: followUpXml,
			},
		}
	}

	/**
	 * Generate contextual suggestions based on tool type and parameters
	 */
	private static generateContextualSuggestions(
		context: TimeoutFallbackContext,
	): Array<{ text: string; mode?: string }> {
		const { toolName, toolParams } = context

		switch (toolName) {
			case "execute_command":
				return this.generateCommandSuggestions(toolParams)
			case "read_file":
				return this.generateReadFileSuggestions(toolParams)
			case "write_to_file":
				return this.generateWriteFileSuggestions(toolParams)
			case "browser_action":
				return this.generateBrowserSuggestions(toolParams)
			case "search_files":
				return this.generateSearchSuggestions(toolParams)
			default:
				return this.generateGenericSuggestions(context)
		}
	}

	private static generateCommandSuggestions(params?: Record<string, any>): Array<{ text: string; mode?: string }> {
		const command = params?.command || "the command"

		return [
			{
				text: `Break "${command}" into smaller, sequential steps that can complete faster`,
			},
			{
				text: `Run "${command}" in the background using '&' or 'nohup' to avoid blocking`,
			},
			{
				text: `Try an alternative approach or tool to accomplish the same goal`,
			},
			{
				text: `Increase the timeout setting if this operation legitimately needs more time`,
			},
		]
	}

	private static generateReadFileSuggestions(params?: Record<string, any>): Array<{ text: string; mode?: string }> {
		const filePath = params?.path || "the file"

		return [
			{
				text: `Read "${filePath}" in smaller chunks using line ranges`,
			},
			{
				text: `Check if "${filePath}" is accessible and not locked by another process`,
			},
			{
				text: `Use a different approach to access the file content`,
			},
			{
				text: `Increase the timeout if this is a legitimately large file`,
			},
		]
	}

	private static generateWriteFileSuggestions(params?: Record<string, any>): Array<{ text: string; mode?: string }> {
		const filePath = params?.path || "the file"

		return [
			{
				text: `Write to "${filePath}" incrementally using insert_content instead`,
			},
			{
				text: `Check if "${filePath}" is writable and not locked`,
			},
			{
				text: `Use apply_diff for targeted changes instead of full file replacement`,
			},
			{
				text: `Break the content into smaller write operations`,
			},
		]
	}

	private static generateBrowserSuggestions(params?: Record<string, any>): Array<{ text: string; mode?: string }> {
		const action = params?.action || "browser action"

		return [
			{
				text: `Simplify the "${action}" into smaller, more targeted steps`,
			},
			{
				text: `Wait for specific elements to load before proceeding`,
			},
			{
				text: `Use direct API calls instead of browser automation if possible`,
			},
			{
				text: `Reset the browser session and try again`,
			},
		]
	}

	private static generateSearchSuggestions(params?: Record<string, any>): Array<{ text: string; mode?: string }> {
		return [
			{
				text: `Narrow the search scope to specific directories`,
			},
			{
				text: `Use simpler search patterns or literal strings`,
			},
			{
				text: `Apply file type filters to reduce search space`,
			},
			{
				text: `Search incrementally in smaller batches`,
			},
		]
	}

	private static generateGenericSuggestions(context: TimeoutFallbackContext): Array<{ text: string; mode?: string }> {
		return [
			{
				text: `Break the ${context.toolName} operation into smaller steps`,
			},
			{
				text: `Try an alternative approach to accomplish the same goal`,
			},
			{
				text: `Check system resources and try again`,
			},
			{
				text: `Increase the timeout setting for this operation`,
			},
		]
	}
}
