import type { ToolName } from "@roo-code/types"
import type { Task } from "../task/Task"
import type { SingleCompletionHandler } from "../../api"
import {
	createTimeoutFallbackPrompt,
	parseTimeoutFallbackResponse,
	type TimeoutFallbackContext,
} from "../prompts/instructions/timeout-fallback"
import { formatResponse } from "../prompts/responses"

export interface TimeoutFallbackResult {
	success: boolean
	toolCall?: {
		name: "ask_followup_question"
		params: {
			question: string
			follow_up: string
		}
	}
	error?: string
}

/**
 * Generates AI-powered fallback suggestions for timeout scenarios
 */
export class TimeoutFallbackGenerator {
	/**
	 * Generate an AI-powered ask_followup_question tool call for timeout scenarios
	 */
	public static async generateAiFallback(
		context: TimeoutFallbackContext,
		task?: Task,
	): Promise<TimeoutFallbackResult> {
		// Try to use AI to generate contextual suggestions
		if (task?.api && "completePrompt" in task.api) {
			try {
				const aiResult = await this.generateAiSuggestions(context, task.api as SingleCompletionHandler)
				if (aiResult.success) {
					return aiResult
				}
			} catch (error) {
				// AI failed, fall through to static suggestions
			}
		}

		// Fallback to static suggestions if AI fails or is unavailable
		const toolCall = this.generateStaticToolCall(context)

		return {
			success: true,
			toolCall,
		}
	}

	/**
	 * Generate AI-powered suggestions using the task's API handler
	 */
	private static async generateAiSuggestions(
		context: TimeoutFallbackContext,
		apiHandler: SingleCompletionHandler,
	): Promise<TimeoutFallbackResult> {
		try {
			const prompt = createTimeoutFallbackPrompt(context)
			const aiResponse = await apiHandler.completePrompt(prompt)

			// Parse the AI response to extract suggestions
			const suggestions = parseTimeoutFallbackResponse(aiResponse)

			if (suggestions.length === 0) {
				throw new Error("No valid suggestions generated by AI")
			}

			const question = `The ${context.toolName} operation timed out after ${Math.round(context.timeoutMs / 1000)} seconds. How would you like to proceed?`

			const followUpXml = suggestions
				.map((suggestion) =>
					suggestion.mode
						? `<suggest mode="${suggestion.mode}">${suggestion.text}</suggest>`
						: `<suggest>${suggestion.text}</suggest>`,
				)
				.join("\n")

			return {
				success: true,
				toolCall: {
					name: "ask_followup_question",
					params: {
						question,
						follow_up: followUpXml,
					},
				},
			}
		} catch (error) {
			return {
				success: false,
				error: error instanceof Error ? error.message : "Unknown error generating AI suggestions",
			}
		}
	}

	/**
	 * Generate static fallback suggestions when AI is unavailable
	 */
	private static generateStaticToolCall(context: TimeoutFallbackContext): TimeoutFallbackResult["toolCall"] {
		const suggestions = formatResponse.timeoutFallbackSuggestions.generateContextualSuggestions(
			context.toolName,
			context.toolParams,
		)

		const question = `The ${context.toolName} operation timed out after ${Math.round(context.timeoutMs / 1000)} seconds. How would you like to proceed?`

		const followUpXml = suggestions
			.map((suggestion) =>
				suggestion.mode
					? `<suggest mode="${suggestion.mode}">${suggestion.text}</suggest>`
					: `<suggest>${suggestion.text}</suggest>`,
			)
			.join("\n")

		return {
			name: "ask_followup_question",
			params: {
				question,
				follow_up: followUpXml,
			},
		}
	}
}
